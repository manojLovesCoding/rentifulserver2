var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/platform/_lib/utils.ts
import internals2 from "@prisma/internals";
import { bold, green } from "kleur/colors";

// src/platform/_lib/cli/parameters.ts
import internals from "@prisma/internals";
var getRequiredParameter = (args, names, environmentVariable) => {
  const value = getOptionalParameter(args, names, environmentVariable);
  if (value === void 0)
    return new Error(`Missing ${names.join(" or ")} parameter`);
  return value;
};
function argOrThrow(argv, spec) {
  const args = internals.arg(argv, spec);
  if (internals.isError(args))
    throw args;
  return args;
}
var getRequiredParameterOrThrow = (args, names, environmentVariable) => {
  const value = getRequiredParameter(args, names, environmentVariable);
  if (value instanceof Error)
    throw new Error(`Missing ${names.join(" or ")} parameter`);
  return value;
};
var getOptionalParameter = (args, names, environmentVariable) => {
  const entry = Object.entries(args).find(([key]) => names.includes(key));
  if (!entry) {
    if (environmentVariable) {
      const value = process.env[environmentVariable];
      if (value) {
        return value;
      }
    }
  }
  return entry?.[1] ?? void 0;
};

// src/platform/_lib/credentials.ts
import fs2 from "fs-extra";
import path from "path";
import XdgAppPaths from "xdg-app-paths";

// src/platform/_lib/jsonFile.ts
import fs from "fs-extra";
var parse = (buffer, { beforeParse, reviver } = {}) => {
  let data = new TextDecoder().decode(buffer);
  if (typeof beforeParse === "function") {
    data = beforeParse(data);
  }
  return JSON.parse(data, reviver);
};
var loadJsonFile = async (filePath, options) => {
  const buffer = await fs.readFile(filePath);
  return parse(buffer, options);
};

// src/platform/_lib/prelude.ts
var unknownToError = (unknown) => {
  if (unknown instanceof Error)
    return unknown;
  return new Error(`Unknown error: ${unknown}`);
};
var id = (value) => value;
var isObject = (obj) => {
  return obj !== null && typeof obj === "object" && !Array.isArray(obj);
};
var tryCatch = (fn, catcher) => {
  try {
    return fn();
  } catch (e) {
    return catcher ? catcher(unknownToError(e)) : unknownToError(e);
  }
};

// src/platform/_lib/credentials.ts
var credentialsFileDirectoryPath = new XdgAppPaths("prisma-platform-cli").config();
var credentialsFilePath = path.join(credentialsFileDirectoryPath, "auth.json");
var parseCredentials = (data) => {
  if (typeof data !== "object" || data === null)
    throw new Error("Invalid credentials");
  if (!("token" in data) || typeof data["token"] !== "string")
    throw new Error("Invalid credentials");
  return data;
};
var credentialsFile = {
  path: credentialsFilePath,
  save: async (data) => fs2.mkdirp(credentialsFileDirectoryPath).then(() => fs2.writeJSON(credentialsFilePath, data)).catch(unknownToError),
  load: async () => fs2.pathExists(credentialsFilePath).then((exists) => exists ? loadJsonFile(credentialsFilePath).then(parseCredentials) : null).catch(unknownToError),
  delete: async () => fs2.pathExists(credentialsFilePath).then((exists) => exists ? fs2.remove(credentialsFilePath) : void 0).then(() => null).catch(unknownToError)
};

// src/platform/_lib/utils.ts
var platformParameters = {
  global: {
    // TODO Remove this from global once we have a way for parents to strip out flags upon parsing.
    "--token": String,
    "--json": Boolean
  },
  workspace: {
    "--token": String,
    "--workspace": String,
    "--json": Boolean,
    "-w": "--workspace"
  },
  project: {
    "--token": String,
    "--project": String,
    "-p": "--project"
  },
  environment: {
    "--token": String,
    "--environment": String,
    "-e": "--environment"
  },
  serviceToken: {
    "--token": String,
    "--serviceToken": String,
    "-s": "--serviceToken"
  },
  apikey: {
    "--token": String,
    "--apikey": String
  }
};
var ErrorPlatformUnauthorized = new Error(
  `No platform credentials found. Run ${green(internals2.getCommandWithExecutor("prisma platform auth login --early-access"))} first. Alternatively you can provide a token via the \`--token\` or \`-t\` parameters, or set the 'PRISMA_TOKEN' environment variable with a token.`
  // prettier-ignore
);
var getTokenOrThrow = async (args) => {
  const token = getOptionalParameter(args, ["--token", "-t"], "PRISMA_TOKEN");
  if (token)
    return token;
  const credentials = await credentialsFile.load();
  if (internals2.isError(credentials))
    throw credentials;
  if (!credentials)
    throw ErrorPlatformUnauthorized;
  return credentials.token;
};
var accelerateConnectionStringUrl = "prisma://accelerate.prisma-data.net";
var generateConnectionString = (apiKey) => {
  const url = new URL(accelerateConnectionStringUrl);
  url.searchParams.set("api_key", apiKey);
  return bold(url.href);
};
var poll = async (fn, until, waitMs, timeoutMs, message) => {
  const endTime = (/* @__PURE__ */ new Date()).getMilliseconds() + timeoutMs;
  const wait = () => new Promise((resolve) => {
    setTimeout(resolve, waitMs);
  });
  let result = await fn();
  while (!until(result)) {
    const waitTime = (/* @__PURE__ */ new Date()).getMilliseconds() + waitMs;
    if (waitTime > endTime) {
      throw new Error(`polling timed out after ${timeoutMs}ms`);
    }
    if (message)
      console.log(message);
    result = await wait().then(fn);
  }
  if (internals2.isError(result))
    throw result;
  return result;
};
var printPpgInitOutput = ({
  databaseUrl,
  workspaceId,
  projectId,
  environmentId,
  isExistingPrismaProject = false
}) => {
  const newPrismaProjectOutput = `
We created an initial ${green("schema.prisma")} file and a ${green(".env")} file with your ${green(
    "DATABASE_URL"
  )} environment variable already set.

${bold("--- Next steps ---")}

Go to ${internals2.link("https://pris.ly/ppg-init")} for detailed instructions.

${bold("1. Define your database schema")}
Open the ${green("schema.prisma")} file and define your first models. Check the docs if you need inspiration: ${internals2.link(
    "https://pris.ly/ppg-init"
  )}.

${bold("2. Apply migrations")}
Run the following command to create and apply a migration:
${green("npx prisma migrate dev --name init")}

${bold(`3. Manage your data`)}
View and edit your data locally by running this command:
${green("npx prisma studio")}

...or online in Console:
${internals2.link(`https://console.prisma.io/${workspaceId}/${projectId}/${environmentId}/studio`)}

${bold(`4. Send queries from your app`)}
To access your database from a JavaScript/TypeScript app, you need to use Prisma ORM. Go here for step-by-step instructions: ${internals2.link(
    "https://pris.ly/ppg-init"
  )}
  `;
  const existingPrismaProjectOutput = `
We found an existing ${green("schema.prisma")} file in your current project directory.

${bold("--- Database URL ---")}

Connect Prisma ORM to your Prisma Postgres database with this URL:

${green(databaseUrl)}

${bold("--- Next steps ---")}

Go to ${internals2.link("https://pris.ly/ppg-init")} for detailed instructions.

${bold("1. Install and use the Prisma Accelerate extension")}
Prisma Postgres requires the Prisma Accelerate extension for querying. If you haven't already installed it, install it in your project:
${green("npm install @prisma/extension-accelerate")}

...and add it to your Prisma Client instance:
${green('import { withAccelerate } from "@prisma/extension-accelerate"')}

${green("const prisma = new PrismaClient().$extends(withAccelerate())")}

${bold("2. Apply migrations")}
Run the following command to create and apply a migration:
${green("npx prisma migrate dev")}

${bold(`3. Manage your data`)}
View and edit your data locally by running this command:
${green("npx prisma studio")}

...or online in Console:
${internals2.link(`https://console.prisma.io/${workspaceId}/${projectId}/${environmentId}/studio`)}

${bold(`4. Send queries from your app`)}
If you already have an existing app with Prisma ORM, you can now run it and it will send queries against your newly created Prisma Postgres instance.

${bold(`5. Learn more`)}
For more info, visit the Prisma Postgres docs: ${internals2.link("https://pris.ly/ppg-docs")}
`;
  return isExistingPrismaProject ? existingPrismaProjectOutput : newPrismaProjectOutput;
};

// src/platform/accelerate/_.ts
var __exports = {};
__export(__exports, {
  $: () => $,
  Disable: () => Disable,
  Enable: () => Enable
});

// src/platform/_lib/cli/dispatchToSubCommand.ts
import internals3 from "@prisma/internals";
var { HelpError, link } = internals3;
var dispatchToSubCommand = async (commands, argv, config) => {
  const commandName = argv[0];
  if (!commandName)
    return new HelpError(`Unknown command.`);
  const command = commands[commandName];
  if (!command)
    return new HelpError(`Unknown command or parameter "${commandName}"`);
  const hasHelpFlag = Boolean(argv.find((it) => ["-h", "--help"].includes(it)));
  if (hasHelpFlag)
    return `Help output for this command will be available soon. In the meantime, visit ${link("https://pris.ly/cli/platform-docs")} for more information.`;
  const result = await command.parse(argv.slice(1), config);
  return result;
};

// src/platform/_lib/cli/namespace.ts
var createNamespace = () => {
  return class $7 {
    constructor(commands) {
      this.commands = commands;
    }
    static new(commands) {
      return new $7(commands);
    }
    async parse(argv, config) {
      return await dispatchToSubCommand(this.commands, argv, config);
    }
  };
};

// src/platform/accelerate/$.ts
var $ = createNamespace();

// src/platform/_lib/messages.ts
import internals4 from "@prisma/internals";
import { bold as bold2, dim, green as green2, white } from "kleur/colors";
var table = (object, renderersInput) => {
  const renderers = {
    key: renderersInput.key ?? dim,
    // eslint-disable-next-line
    values: internals4.mapObjectValues(
      renderersInput.values ?? {},
      (_) => _ === true ? id : _
    )
  };
  return internals4.formatTable(
    Object.entries(renderers.values).map(([propertyName, renderer]) => {
      const valueRendered = renderer(object[propertyName]);
      if (valueRendered === null)
        return null;
      return [renderers.key(String(propertyName)), valueRendered];
    }).filter(Boolean)
  );
};
var successMessage = (message) => `${green2("Success!")} ${message}`;
var messages = {
  resourceCreated: (resource) => successMessage(`${resource.__typename} ${resource.displayName} - ${resource.id} created.`),
  resourceDeleted: (resource) => successMessage(`${resource.__typename} ${resource.displayName} - ${resource.id} deleted.`),
  resource: (resource, renderers) => {
    return messages.table(resource, {
      values: {
        displayName: (_) => white(bold2(_)),
        id: true,
        createdAt: (_) => _ ? Intl.DateTimeFormat().format(new Date(_)) : null,
        ...renderers
      }
    });
  },
  resourceList: (records) => {
    if (records.length === 0)
      return messages.info("No records found.");
    return records.map((record) => messages.resource(record)).join("\n\n\n");
  },
  info: (message) => message,
  sections: (sections) => sections.join("\n\n"),
  table,
  success: successMessage
};

// src/platform/_lib/pdp.ts
import fetch, { Headers } from "node-fetch";

// src/platform/_lib/userAgent.ts
import Debug from "@prisma/debug";
import internals5 from "@prisma/internals";
import * as Checkpoint from "checkpoint-client";

// package.json
var version = "0.0.5";

// src/platform/_lib/userAgent.ts
var debug = Debug("prisma:cli:platform:_lib:userAgent");
var getUserAgent = async () => {
  const signature = await Checkpoint.getSignature().catch(unknownToError);
  if (internals5.isError(signature))
    debug(`await checkpoint.getSignature() failed silently with ${signature.message}`);
  const signatureString = internals5.isError(signature) ? "unknown" : signature;
  return `prisma-cli-init/${version} (Signature: ${signatureString})`;
};

// src/platform/_lib/pdp.ts
var platformAPIEndpoint = new URL("https://console.prisma.io/api");
var consoleUrl = new URL("https://console.prisma.io");
var requestOrThrow = async (params) => {
  const userAgent = await getUserAgent();
  const method = "POST";
  const headers = new Headers({
    "Content-Type": "application/json",
    Authorization: `Bearer ${params.token}`,
    // See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent
    "User-Agent": userAgent
  });
  const body = JSON.stringify(params.body);
  const response = await fetch(platformAPIEndpoint.href, { method, headers, body });
  const text = await response.text();
  if (response.status >= 400)
    throw new Error(text);
  const json = JSON.parse(text);
  if (json.error)
    throw new Error(`Error from PDP Platform API: ${text}`);
  const error = Object.values(json.data).filter(
    (rootFieldValue) => typeof rootFieldValue === "object" && rootFieldValue !== null && rootFieldValue["__typename"]?.startsWith("Error")
  )[0];
  if (error)
    throw errorFromPlatformError({ message: "<message not selected from server>", ...error });
  return json.data;
};
var errorFromPlatformError = (error) => {
  return new Error(error.message);
};

// src/platform/accelerate/disable.ts
var Disable = class _Disable {
  static new() {
    return new _Disable();
  }
  async parse(argv, _config) {
    const args = argOrThrow(argv, {
      ...platformParameters.environment
    });
    const token = await getTokenOrThrow(args);
    const environmentId = getRequiredParameterOrThrow(args, ["--environment", "-e"]);
    await requestOrThrow({
      token,
      body: {
        query: (
          /* GraphQL */
          `
          mutation ($input: MutationAccelerateDisableInput!) {
            accelerateDisable(input: $input) {
              __typename
              ... on Error {
                message
              }
            }
          }
        `
        ),
        variables: {
          input: { environmentId }
        }
      }
    });
    return messages.success(
      `Accelerate disabled. Prisma clients connected to ${environmentId} will not be able to send queries through Accelerate.`
    );
  }
};

// src/platform/accelerate/enable.ts
import internals6 from "@prisma/internals";
var Enable = class _Enable {
  static new() {
    return new _Enable();
  }
  async parse(argv, _config) {
    const args = internals6.arg(argv, {
      ...platformParameters.environment,
      "--url": String,
      // TODO rename to "serviceToken" in a future release.
      "--apikey": Boolean,
      "--region": String
    });
    if (internals6.isError(args))
      return args;
    const token = await getTokenOrThrow(args);
    const environmentId = getRequiredParameterOrThrow(args, ["--environment", "-e"]);
    const connectionString = getRequiredParameterOrThrow(args, ["--url"]);
    const withServiceToken = getOptionalParameter(args, ["--apikey"]) ?? false;
    const regionId = getOptionalParameter(args, ["--region"]);
    const { databaseLinkCreate } = await requestOrThrow({
      token,
      body: {
        query: (
          /* GraphQL */
          `
          mutation ($input: MutationDatabaseLinkCreateInput!) {
            databaseLinkCreate(input: $input) {
              __typename
              ... on Error {
                message
              }
              ... on DatabaseLink {
                id
              }
            }
          }
        `
        ),
        variables: {
          input: {
            environmentId,
            connectionString,
            ...regionId && { regionId }
          }
        }
      }
    });
    const { serviceTokenCreate } = await requestOrThrow({
      token,
      body: {
        query: (
          /* GraphQL */
          `
          mutation (
            $accelerateEnableInput: MutationAccelerateEnableInput!
            $serviceTokenCreateInput: MutationServiceTokenCreateInput!
            $withServiceToken: Boolean!
          ) {
            accelerateEnable(input: $accelerateEnableInput) {
              __typename
              ... on Error {
                message
              }
            }
            serviceTokenCreate(input: $serviceTokenCreateInput) @include(if: $withServiceToken) {
              __typename
              ... on Error {
                message
              }
              ... on ServiceTokenWithValue {
                value
              }
            }
          }
        `
        ),
        variables: {
          withServiceToken,
          accelerateEnableInput: { databaseLinkId: databaseLinkCreate.id },
          serviceTokenCreateInput: { environmentId }
        }
      }
    });
    const gettingStartedUrl = internals6.link("https://pris.ly/d/accelerate-getting-started");
    if (serviceTokenCreate) {
      return messages.success(
        `Accelerate enabled. Use this Accelerate connection string to authenticate requests:

${generateConnectionString(serviceTokenCreate.value)}

For more information, check out the Getting started guide here: ${gettingStartedUrl}`
      );
    } else {
      return messages.success(
        `Accelerate enabled. Use your secure API key in your Accelerate connection string to authenticate requests.

For more information, check out the Getting started guide here: ${gettingStartedUrl}`
      );
    }
  }
};

// src/platform/auth/_.ts
var __exports2 = {};
__export(__exports2, {
  $: () => $2,
  Login: () => Login,
  Logout: () => Logout,
  Show: () => Show,
  loginOrSignup: () => loginOrSignup
});

// src/platform/auth/$.ts
var $2 = createNamespace();

// src/platform/auth/login.ts
import { select } from "@inquirer/prompts";
import Debug2 from "@prisma/debug";
import internals7 from "@prisma/internals";
import { listen } from "async-listen";
import http from "http";
import { green as green3 } from "kleur/colors";
import open from "open";
var debug2 = Debug2("prisma:cli:platform:login");
var Login = class _Login {
  static new() {
    return new _Login();
  }
  async parse(argv, _config) {
    const args = internals7.arg(argv, {
      // internal optimize flag to track signup attribution
      "--optimize": Boolean
    });
    if (internals7.isError(args))
      return args;
    if (args["--optimize"]) {
      console.warn("The '--optimize' flag is deprecated. Use API keys instead.");
    }
    const credentials = await credentialsFile.load();
    if (internals7.isError(credentials))
      throw credentials;
    if (credentials)
      return `Already authenticated. Run ${green3(internals7.getCommandWithExecutor("prisma platform auth show --early-access"))} to see the current user.`;
    console.info("Authenticating to Prisma Platform CLI via browser.\n");
    const server = http.createServer();
    const randomPort = 0;
    const redirectUrl = await listen(server, randomPort, "127.0.0.1");
    const loginUrl = await createLoginUrl({ connection: "github", redirectTo: redirectUrl.href });
    console.info("Visit the following URL in your browser to authenticate:");
    console.info(internals7.link(loginUrl.href));
    const callbackResult = await Promise.all([
      new Promise((resolve, reject) => {
        server.once("request", (req, res) => {
          server.close();
          res.setHeader("connection", "close");
          const searchParams = new URL(req.url || "/", "http://localhost").searchParams;
          const token = searchParams.get("token") ?? "";
          const error = searchParams.get("error");
          const location = getBaseAuthUrl();
          if (error) {
            location.pathname += "/error";
            location.searchParams.set("error", error);
            reject(new Error(error));
          } else {
            const user = decodeUser(searchParams.get("user") ?? "");
            if (user) {
              searchParams.delete("token");
              searchParams.delete("user");
              location.pathname += "/success";
              const nextSearchParams = new URLSearchParams({
                ...Object.fromEntries(searchParams.entries()),
                email: user.email
              });
              location.search = nextSearchParams.toString();
              resolve({ token, user });
            } else {
              location.pathname += "/error";
              location.searchParams.set("error", "Invalid user");
              reject(new Error("Invalid user"));
            }
          }
          res.statusCode = 302;
          res.setHeader("location", location.href);
          res.end();
        });
        server.once("error", reject);
      }),
      open(loginUrl.href)
    ]).then((results) => results[0]).catch(unknownToError);
    if (internals7.isError(callbackResult))
      throw new Error(`Authentication failed: ${callbackResult.message}`);
    {
      const writeResult = await credentialsFile.save({ token: callbackResult.token });
      if (internals7.isError(writeResult))
        throw new Error("Writing credentials to disk failed", { cause: writeResult });
    }
    return successMessage(`Authentication successful for ${callbackResult.user.email}`);
  }
};
var getBaseAuthUrl = () => new URL("/auth/cli", consoleUrl);
var createLoginUrl = async (params) => {
  const userAgent = await getUserAgent();
  const state = {
    client: userAgent,
    ...params
  };
  const stateEncoded = encodeState(state);
  const url = getBaseAuthUrl();
  url.searchParams.set("state", stateEncoded);
  return url;
};
var encodeState = (state) => Buffer.from(JSON.stringify(state), "utf-8").toString("base64");
var decodeUser = (stringifiedUser) => {
  try {
    const maybeUser = JSON.parse(Buffer.from(stringifiedUser, `base64`).toString(`utf-8`));
    if (typeof maybeUser !== "object" || maybeUser === null)
      return false;
    const isUser = typeof maybeUser.id === "string" && typeof maybeUser.displayName === "string" && typeof maybeUser.email === "string";
    return isUser ? maybeUser : null;
  } catch (e) {
    debug2(`parseUser() failed silently with ${e}`);
    return null;
  }
};
var loginOrSignup = async () => {
  const providerAnswer = await select({
    message: "Select an authentication method",
    default: "google",
    choices: [
      { name: "Google", value: "google" },
      { name: "GitHub", value: "github" }
    ]
  });
  console.info("Authenticating to Prisma Platform via browser.\n");
  const server = http.createServer();
  const randomPort = 0;
  const redirectUrl = await listen(server, randomPort, "127.0.0.1");
  const loginUrl = await createLoginUrl({ connection: providerAnswer, redirectTo: redirectUrl.href });
  console.info("Visit the following URL in your browser to authenticate:");
  console.info(internals7.link(loginUrl.href));
  const callbackResult = await Promise.all([
    new Promise((resolve, reject) => {
      server.once("request", (req, res) => {
        server.close();
        res.setHeader("connection", "close");
        const searchParams = new URL(req.url || "/", "http://localhost").searchParams;
        const token = searchParams.get("token") ?? "";
        const error = searchParams.get("error");
        const location = getBaseAuthUrl();
        if (error) {
          location.pathname += "/error";
          location.searchParams.set("error", error);
          reject(new Error(error));
        } else {
          const user = decodeUser(searchParams.get("user") ?? "");
          if (user) {
            searchParams.delete("token");
            searchParams.delete("user");
            location.pathname += "/success";
            const nextSearchParams = new URLSearchParams({
              ...Object.fromEntries(searchParams.entries()),
              email: user.email
            });
            location.search = nextSearchParams.toString();
            resolve({ token, user });
          } else {
            location.pathname += "/error";
            location.searchParams.set("error", "Invalid user");
            reject(new Error("Invalid user"));
          }
        }
        res.statusCode = 302;
        res.setHeader("location", location.href);
        res.end();
      });
      server.once("error", reject);
    }),
    open(loginUrl.href)
  ]).then((results) => results[0]).catch(unknownToError);
  if (internals7.isError(callbackResult))
    throw new Error(`Authentication failed: ${callbackResult.message}`);
  {
    const writeResult = await credentialsFile.save({ token: callbackResult.token });
    if (internals7.isError(writeResult))
      throw new Error("Writing credentials to disk failed", { cause: writeResult });
  }
  return {
    message: successMessage(`Authentication successful for ${callbackResult.user.email}`),
    email: callbackResult.user.email,
    token: callbackResult.token
  };
};

// src/platform/auth/logout.ts
import internals9 from "@prisma/internals";
import { green as green4 } from "kleur/colors";

// src/platform/_lib/jwt.ts
import internals8 from "@prisma/internals";
var decodeJwt = (jwt) => {
  if (typeof jwt !== "string")
    throw new Error("JWTs must use Compact JWS serialization, JWT must be a string");
  const { 1: payload, length } = jwt.split(".");
  if (length === 5)
    throw new Error("Only JWTs using Compact JWS serialization can be decoded");
  if (length !== 3)
    throw new Error("Invalid JWT");
  if (!payload)
    throw new Error("JWTs must contain a payload");
  const decoded = tryCatch(
    () => atob(payload),
    () => new Error("Failed to base64 decode the payload.")
  );
  if (internals8.isError(decoded))
    return decoded;
  const result = tryCatch(
    () => JSON.parse(decoded),
    () => new Error("Failed to parse the decoded payload as JSON.")
  );
  if (internals8.isError(result))
    return result;
  if (!isObject(result))
    throw new Error("Invalid JWT Claims Set.");
  return result;
};

// src/platform/auth/logout.ts
var Logout = class _Logout {
  static new() {
    return new _Logout();
  }
  async parse() {
    const credentials = await credentialsFile.load();
    if (internals9.isError(credentials))
      throw credentials;
    if (!credentials)
      return `You are not currently logged in. Run ${green4(internals9.getCommandWithExecutor("prisma platform auth login --early-access"))} to log in.`;
    if (credentials.token) {
      const jwt = decodeJwt(credentials.token);
      if (!internals9.isError(jwt) && jwt.jti) {
        await requestOrThrow({
          token: credentials.token,
          body: {
            query: (
              /* GraphQL */
              `
              mutation ($input: MutationManagementTokenDeleteInput!) {
                managementTokenDelete(input: $input) {
                  __typename
                  ... on Error {
                    message
                  }
                }
              }
            `
            ),
            variables: {
              input: {
                id: jwt.jti
              }
            }
          }
        });
      }
    }
    await credentialsFile.delete();
    return successMessage("You have logged out.");
  }
};

// src/platform/auth/show.ts
import { green as green5 } from "kleur/colors";
var Show = class _Show {
  static new() {
    return new _Show();
  }
  async parse(argv, _config) {
    const args = argOrThrow(argv, {
      ...platformParameters.global,
      "--sensitive": Boolean
    });
    const token = await getTokenOrThrow(args);
    const { me } = await requestOrThrow({
      token,
      body: {
        query: (
          /* graphql */
          `
          query {
            me {
              __typename
              user {
                __typename
                id
                email
                displayName
              }
            }
          }
        `
        )
      }
    });
    const data = {
      ...me.user,
      token: getOptionalParameter(args, ["--sensitive"]) ? token : null
    };
    return messages.sections([
      messages.info(`Currently authenticated as ${green5(me.user.email)}`),
      messages.resource(data, {
        email: true,
        token: true
      })
    ]);
  }
};

// src/platform/environment/_.ts
var __exports3 = {};
__export(__exports3, {
  $: () => $3,
  Create: () => Create,
  Delete: () => Delete,
  Show: () => Show2,
  getEnvironmentOrThrow: () => getEnvironmentOrThrow
});

// src/platform/environment/$.ts
var $3 = createNamespace();

// src/platform/environment/create.ts
var Create = class _Create {
  static new() {
    return new _Create();
  }
  async parse(argv, _config) {
    const args = argOrThrow(argv, {
      ...platformParameters.project,
      "--name": String,
      "-n": "--name"
    });
    const token = await getTokenOrThrow(args);
    const projectId = getRequiredParameterOrThrow(args, ["--project", "-p"]);
    const displayName = getOptionalParameter(args, ["--name", "-n"]);
    const { environmentCreate } = await requestOrThrow({
      token,
      body: {
        query: (
          /* graphql */
          `
          mutation ($input: MutationEnvironmentCreateInput!) {
            environmentCreate(input: $input) {
              __typename
              ...on Error {
                message
              }
              ...on Environment {
                id
                createdAt
                displayName
              }
            }
          }
        `
        ),
        variables: {
          input: {
            projectId,
            displayName
          }
        }
      }
    });
    return messages.resourceCreated(environmentCreate);
  }
};

// src/platform/environment/delete.ts
import internals10 from "@prisma/internals";
var Delete = class _Delete {
  static new() {
    return new _Delete();
  }
  async parse(argv, _config) {
    const args = internals10.arg(argv, {
      ...platformParameters.environment
    });
    if (internals10.isError(args))
      return args;
    const token = await getTokenOrThrow(args);
    const environmentId = getRequiredParameterOrThrow(args, ["--environment", "-e"]);
    const { environmentDelete } = await requestOrThrow({
      token,
      body: {
        query: (
          /* graphql */
          `
          mutation ($input: MutationEnvironmentDeleteInput!) {
            environmentDelete(input: $input) {
              __typename
              ...on Error {
                message
              }
              ...on Environment {
                id
                createdAt
                displayName
              }
            }
          }
        `
        ),
        variables: {
          input: {
            id: environmentId
          }
        }
      }
    });
    return messages.resourceDeleted(environmentDelete);
  }
};

// src/platform/environment/show.ts
import internals11 from "@prisma/internals";
var Show2 = class _Show {
  static new() {
    return new _Show();
  }
  async parse(argv, _config) {
    const args = internals11.arg(argv, {
      ...platformParameters.project
    });
    if (internals11.isError(args))
      return args;
    const token = await getTokenOrThrow(args);
    const projectId = getRequiredParameterOrThrow(args, ["--project", "-p"]);
    const { project } = await requestOrThrow({
      token,
      body: {
        query: (
          /* GraphQL */
          `
          query ($input: QueryProjectInput!) {
            project(input: $input) {
              __typename
              ... on Error {
                message
              }
              ... on Project {
                environments {
                  __typename
                  id
                  createdAt
                  displayName
                }
              }
            }
          }
        `
        ),
        variables: {
          input: {
            id: projectId
          }
        }
      }
    });
    return messages.resourceList(project.environments);
  }
};
var getEnvironmentOrThrow = async (input) => {
  const { token, environmentId } = input;
  const { environment } = await requestOrThrow({
    token,
    body: {
      query: (
        /* GraphQL */
        `
        query ($input: QueryEnvironmentInput!) {
          environment(input: $input) {
            __typename
            ... on Error {
              message
            }
            ... on Environment {
              __typename
              id
              displayName
              ppg {
                status
              }
              accelerate {
                status {
                  ... on AccelerateStatusEnabled {
                    __typename
                    enabled
                  }
                  ... on AccelerateStatusDisabled {
                    __typename
                    enabled
                  }
                }
              }
            }
          }
        }
      `
      ),
      variables: {
        input: {
          id: environmentId
        }
      }
    }
  });
  return environment;
};

// src/platform/project/_.ts
var __exports4 = {};
__export(__exports4, {
  $: () => $4,
  Create: () => Create2,
  Delete: () => Delete2,
  Show: () => Show3,
  createProjectOrThrow: () => createProjectOrThrow
});

// src/platform/project/$.ts
var $4 = createNamespace();

// src/platform/project/create.ts
var Create2 = class _Create {
  static new() {
    return new _Create();
  }
  async parse(argv, _config) {
    const args = argOrThrow(argv, {
      ...platformParameters.workspace,
      "--name": String,
      "-n": "--name"
    });
    const workspaceId = getRequiredParameterOrThrow(args, ["--workspace", "-w"]);
    const displayName = getOptionalParameter(args, ["--name", "-n"]);
    const project = await createProjectOrThrow({
      token: await getTokenOrThrow(args),
      workspaceId,
      displayName
    });
    return messages.resourceCreated(project);
  }
};
var createProjectOrThrow = async (input) => {
  const { token, ...mutationInput } = input;
  const { projectCreate } = await requestOrThrow({
    token,
    body: {
      query: (
        /* graphql */
        `
        mutation ($input: MutationProjectCreateInput!) {
          projectCreate(input: $input) {
            __typename
            ...on Error {
              message
            }
            ...on Project {
              id
              createdAt
              displayName
              defaultEnvironment {
                id
                displayName
              }
            }
          }
        }
      `
      ),
      variables: {
        input: mutationInput
      }
    }
  });
  return projectCreate;
};

// src/platform/project/delete.ts
import internals12 from "@prisma/internals";
var Delete2 = class _Delete {
  static new() {
    return new _Delete();
  }
  async parse(argv, _config) {
    const args = internals12.arg(argv, {
      ...platformParameters.project
    });
    if (internals12.isError(args))
      return args;
    const token = await getTokenOrThrow(args);
    const projectId = getRequiredParameterOrThrow(args, ["--project", "-p"]);
    const { projectDelete } = await requestOrThrow({
      token,
      body: {
        query: (
          /* graphql */
          `
          mutation ($input: MutationProjectDeleteInput!) {
            projectDelete(input: $input) {
              __typename
              ...on Error {
                message
              }
              ...on ProjectNode {
                id
                createdAt
                displayName
              }
            }
          }
        `
        ),
        variables: {
          input: {
            id: projectId
          }
        }
      }
    });
    return messages.resourceDeleted(projectDelete);
  }
};

// src/platform/project/show.ts
import internals13 from "@prisma/internals";
var Show3 = class _Show {
  static new() {
    return new _Show();
  }
  async parse(argv, _config) {
    const args = internals13.arg(argv, {
      ...platformParameters.workspace
    });
    if (internals13.isError(args))
      return args;
    const token = await getTokenOrThrow(args);
    const workspaceId = getRequiredParameterOrThrow(args, ["--workspace", "-w"]);
    const { workspace } = await requestOrThrow({
      token,
      body: {
        query: (
          /* GraphQL */
          `
          query ($input: QueryWorkspaceInput!) {
            workspace(input: $input) {
              __typename
              ... on Error {
                message
              }
              ... on Workspace {
                projects {
                  __typename
                  id
                  createdAt
                  displayName
                }
              }
            }
          }
        `
        ),
        variables: {
          input: {
            id: workspaceId
          }
        }
      }
    });
    return messages.resourceList(workspace.projects);
  }
};

// src/platform/serviceToken/_.ts
var __exports5 = {};
__export(__exports5, {
  $: () => $5,
  Create: () => Create3,
  Delete: () => Delete3,
  Show: () => Show4,
  createOrThrow: () => createOrThrow
});

// src/platform/serviceToken/$.ts
var $5 = createNamespace();

// src/platform/serviceToken/create.ts
var Create3 = class _Create {
  constructor(legacy = false) {
    this.legacy = legacy;
  }
  static new(legacy = false) {
    return new _Create(legacy);
  }
  async parse(argv, _config) {
    const args = argOrThrow(argv, {
      ...platformParameters.environment,
      "--name": String,
      "-n": "--name"
    });
    const token = await getTokenOrThrow(args);
    const environmentId = getRequiredParameterOrThrow(args, ["--environment", "-e"]);
    const displayName = getOptionalParameter(args, ["--name", "-n"]);
    const serviceTokenCreate = await createOrThrow({ environmentId, displayName, token });
    const resource = this.legacy ? {
      ...serviceTokenCreate.serviceToken,
      __typename: "APIKey"
    } : serviceTokenCreate.serviceToken;
    return messages.sections([messages.resourceCreated(resource), messages.info(serviceTokenCreate.value)]);
  }
};
var createOrThrow = async (input) => {
  const { environmentId, displayName, token } = input;
  const { serviceTokenCreate } = await requestOrThrow({
    token,
    body: {
      query: (
        /* GraphQL */
        `
        mutation ($input: MutationServiceTokenCreateInput!) {
          serviceTokenCreate(input: $input) {
            __typename
            ... on Error {
              message
            }
            ... on ServiceTokenWithValue {
              value
              serviceToken {
                __typename
                id
                createdAt
                displayName
              }
            }
          }
        }
      `
      ),
      variables: {
        input: {
          displayName,
          environmentId
        }
      }
    }
  });
  return serviceTokenCreate;
};

// src/platform/serviceToken/delete.ts
var Delete3 = class _Delete {
  constructor(legacy = false) {
    this.legacy = legacy;
  }
  static new(legacy = false) {
    return new _Delete(legacy);
  }
  async parse(argv, _config) {
    const args = argOrThrow(argv, {
      ...platformParameters[this.legacy ? "apikey" : "serviceToken"]
    });
    const token = await getTokenOrThrow(args);
    const serviceTokenId = this.legacy ? getRequiredParameterOrThrow(args, ["--apikey"]) : getRequiredParameterOrThrow(args, ["--serviceToken", "-s"]);
    const { serviceTokenDelete } = await requestOrThrow({
      token,
      body: {
        query: (
          /* GraphQL */
          `
          mutation ($input: MutationServiceTokenDeleteInput!) {
            serviceTokenDelete(input: $input) {
              __typename
              ... on Error {
                message
              }
              ... on ServiceTokenNode {
                id
                displayName
              }
            }
          }
        `
        ),
        variables: {
          input: {
            id: serviceTokenId
          }
        }
      }
    });
    return messages.resourceDeleted(this.legacy ? { ...serviceTokenDelete, __typename: "APIKey" } : serviceTokenDelete);
  }
};

// src/platform/serviceToken/show.ts
import internals14 from "@prisma/internals";
var Show4 = class _Show {
  constructor(legacy = false) {
    this.legacy = legacy;
  }
  static new(legacy = false) {
    return new _Show(legacy);
  }
  async parse(argv, _config) {
    const args = internals14.arg(argv, {
      ...platformParameters.environment
    });
    if (internals14.isError(args))
      return args;
    const token = await getTokenOrThrow(args);
    const environmentId = getRequiredParameterOrThrow(args, ["--environment", "-e"]);
    const { environment } = await requestOrThrow({
      token,
      body: {
        query: (
          /* GraphQL */
          `
          query ($input: QueryEnvironmentInput!) {
            environment(input: $input) {
              __typename
              ... on Error {
                message
              }
              ... on Environment {
                serviceTokens {
                  id
                  createdAt
                  displayName
                }
              }
            }
          }
        `
        ),
        variables: {
          input: {
            id: environmentId
          }
        }
      }
    });
    const resources = this.legacy ? environment.serviceTokens.map((serviceToken) => ({ ...serviceToken, __typename: "APIKey" })) : environment.serviceTokens;
    return messages.resourceList(resources);
  }
};

// src/platform/workspace/_.ts
var __exports6 = {};
__export(__exports6, {
  $: () => $6,
  Show: () => Show5,
  getDefaultWorkspaceOrThrow: () => getDefaultWorkspaceOrThrow,
  getUserWorkspacesOrThrow: () => getUserWorkspacesOrThrow
});

// src/platform/workspace/$.ts
var $6 = createNamespace();

// src/platform/workspace/show.ts
var Show5 = class _Show {
  static new() {
    return new _Show();
  }
  async parse(argv, _config) {
    const args = argOrThrow(argv, {
      ...platformParameters.global
    });
    const token = await getTokenOrThrow(args);
    const userWorkspaces = await getUserWorkspacesOrThrow({ token });
    return messages.resourceList(userWorkspaces);
  }
};
var getUserWorkspacesOrThrow = async (input) => {
  const { token } = input;
  const { me } = await requestOrThrow({
    token,
    body: {
      query: (
        /* GraphQL */
        `
        query {
          me {
            __typename
            workspaces {
              id
              displayName
              createdAt
              isDefault
            }
          }
        }
      `
      )
    }
  });
  return me.workspaces;
};
var getDefaultWorkspaceOrThrow = async (input) => {
  const { token } = input;
  const { me } = await requestOrThrow({
    token,
    body: {
      query: (
        /* GraphQL */
        `
        query {
          me {
            __typename
            workspaces {
              id
              displayName
              createdAt
              isDefault
            }
          }
        }
      `
      )
    }
  });
  const defaultWorkspace = me.workspaces.find((_) => _.isDefault);
  if (!defaultWorkspace) {
    throw new Error("No default workspace found");
  }
  return defaultWorkspace;
};

export {
  credentialsFile,
  platformParameters,
  ErrorPlatformUnauthorized,
  getTokenOrThrow,
  generateConnectionString,
  poll,
  printPpgInitOutput,
  successMessage,
  requestOrThrow,
  __exports,
  Login,
  loginOrSignup,
  Logout,
  __exports2,
  __exports3,
  __exports4,
  __exports5,
  __exports6
};
